!function(e) {
    var t = {};
    function o(i) {
        if (t[i])
            return t[i].exports;
        var r = t[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return e[i].call(r.exports, r, r.exports, o),
        r.l = !0,
        r.exports
    }
    o.m = e,
    o.c = t,
    o.d = function(e, t, i) {
        o.o(e, t) || Object.defineProperty(e, t, {
            configurable: !1,
            enumerable: !0,
            get: i
        })
    }
    ,
    o.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return o.d(t, "a", t),
        t
    }
    ,
    o.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    o.p = "",
    o(o.s = 0)
}([function(e, t, o) {
    e.exports = IJEWEL = {},
    o(1),
    o(2)
}
, function(e, t) {
    e.exports = IJEWEL.DiamondLoader = class {
        constructor(e, t) {
            var o = new THREE.LoadingManager;
            o.onProgress = function(e, t, o) {
                console.log(e, t, o)
            }
            ,
            this.envCubeMap = e,
            this.renderer = t,
            this.loader = new THREE.GLTFLoader(o),
            this.prototypeMaterials = [],
            this.diamonds = []
        }
        load(e, t, o) {
            this.onObjectLoad = t,
            this.loader.load(e, this.process.bind(this), function(e) {
                o && o(e.loaded / e.total * 100)
            })
        }
        process(e) {
            this.gltf = e,
            this.findDiamondPrototypes(),
            this.buildDiamondScene()
        }
        findDiamondPrototypes() {
            let e = this;
            this.gltf.scene.traverse(function(t) {
                if (t.isMesh && -1 !== t.name.toUpperCase().search("DIAMOND")) {
                    let o = t.name.substring(0, 8);
                    e.prototypeMaterials[o] || (e.prototypeMaterials[o] = t)
                }
            })
        }
        buildDiamondScene() {
            for (var e in this.prototypeMaterials) {
                const t = this.prototypeMaterials[e]
                  , o = new IJEWEL.DiamondMaterial(t,this.envCubeMap,this.renderer);
                this.prototypeMaterials[e] = o
            }
            let t = this;
            this.gltf.scene.updateMatrixWorld(),
            this.gltf.scene.traverse(function(e) {
                if (e.isMesh && (e.material && (e.material.envMap = t.envCubeMap),
                -1 !== e.name.toUpperCase().search("DIAMOND"))) {
                    let o = e.name.substring(0, 8);
                    if (t.prototypeMaterials[o]) {
                        let i = t.prototypeMaterials[o];
                        const r = new IJEWEL.Diamond(e,i);
                        t.diamonds.push(r)
                    }
                }
            }),
            this.onObjectLoad && this.onObjectLoad(this.gltf.scene)
        }
    }
}
, function(e, t, o) {
    o(3),
    o(4),
    e.exports = IJEWEL.Diamond = class {
        constructor(e, t) {
            this.mesh = e,
            this.mesh.material = t.clone(),
            this.sparkles = [],
            this.mesh.geometry.computeBoundingBox(),
            this.offset = new THREE.Vector3,
            this.mesh.geometry.boundingBox.getCenter(this.offset),
            this.mesh.material.uniforms.centreOffset.value.copy(this.offset),
            this.mesh.geometry.computeBoundingSphere(),
            this.boundingRadius = this.mesh.geometry.boundingSphere.radius,
            this.mesh.material.uniforms.radius.value = this.boundingRadius
        }
        setPosition(e, t, o) {
            this.mesh.position.set(e, t, o)
        }
        setRotation(e, t, o) {
            this.mesh.rotation.set(e, t, o)
        }
        setQuaternion(e, t, o, i) {
            this.mesh.quaternion.set(e, t, o, i)
        }
        setScale(e, t, o) {
            this.mesh.scale.set(e, t, o);
            for (var i = 0; i < this.sparkles.length; i++)
                this.sparkles[i].setScale(e)
        }
        setTransform(e) {
            this.mesh.matrix.copy(e)
        }
        update(e) {
            let t = new THREE.Vector3;
            for (var o = 0; o < this.sparkles.length; o++) {
                this.sparkles[o].syncWithTransform(this.mesh.matrixWorld),
                t.copy(e.position),
                t.sub(this.sparkles[o].mesh.position),
                t.normalize();
                var i = t.x + t.y + t.z;
                this.sparkles[o].setRotation(i * this.sparkles[o].rotationSpeedFactor),
                this.sparkles[o].alignWithCamera(e)
            }
        }
        addSparkle(e) {
            this.sparkles.push(e)
        }
    }
    ,
    e.exports = IJEWEL.DiamondMaterial = class {
        constructor(e, t, o) {
            this.geometry = null,
            this.mesh = null,
            this.normalBakeHelperMesh = null,
            this.envMap = t,
            this.cubeCamera = new THREE.CubeCamera(.01,100,1024),
            this.localScene = new THREE.Scene,
            this.localScene.add(this.cubeCamera),
            this.material = new THREE.ShaderMaterial,
            this.material.extensions = IJEWEL.diamondMaterial.extensions,
            this.material.defines = IJEWEL.diamondMaterial.defines,
            this.material.uniforms = THREE.UniformsUtils.clone(IJEWEL.diamondMaterial.uniforms),
            this.material.uniforms.envMap.value = this.envMap,
            this.material.vertexShader = IJEWEL.diamondMaterial.vertexShader,
            this.material.fragmentShader = IJEWEL.diamondMaterial.fragmentShader,
            this.cubeCamera.renderTarget.texture.generateMipmaps = !1,
            this.cubeCamera.renderTarget.texture.magFilter = THREE.NearestFilter,
            this.cubeCamera.renderTarget.texture.minFilter = THREE.NearestFilter,
            this.cubeCamera.renderTarget.texture.format = THREE.RGBAFormat,
            this.needsNormalsUpdate = !0,
            this.mesh = e,
            this.normalBakeHelperMesh = this.mesh.clone(),
            this.normalBakeHelperMesh.material = IJEWEL.normalMapCaptureMaterial,
            this.normalBakeHelperMesh.geometry = e.geometry.clone(),
            this.normalBakeHelperMesh.geometry.center(),
            this.geometry = e.geometry,
            this.geometry.computeBoundingBox(),
            this.offset = new THREE.Vector3,
            this.geometry.boundingBox.getCenter(this.offset),
            this.geometry.computeBoundingSphere(),
            this.normalBakeHelperMesh.position.set(0, 0, 0),
            this.normalBakeHelperMesh.rotation.set(0, 0, 0),
            this.normalBakeHelperMesh.quaternion.set(0, 0, 0, 1),
            this.normalBakeHelperMesh.scale.set(1, 1, 1),
            this.localScene.add(this.normalBakeHelperMesh),
            this.prepareNormalsCubeMap(o),
            this.sparkles = []
        }
        clone() {
            const e = new THREE.ShaderMaterial;
            return e.uniforms = THREE.UniformsUtils.clone(this.material.uniforms),
            e.extensions = this.material.extensions,
            e.defines = this.material.defines,
            e.uniforms.tCubeMapNormals.value = this.cubeCamera.renderTarget,
            e.uniforms.envMap.value = this.envMap,
            e.envMap = this.envMap,
            e.vertexShader = this.material.vertexShader,
            e.fragmentShader = this.material.fragmentShader,
            e
        }
        prepareNormalsCubeMap(e) {
            this.needsNormalsUpdate && (this.cubeCamera.updateCubeMap(e, this.localScene),
            this.material.uniforms.tCubeMapNormals.value = this.cubeCamera.renderTarget,
            this.needsNormalsUpdate = !1)
        }
    }
}
, function(e, t) {
    e.exports = IJEWEL.NormalMapCaptureShader = {
        vertexShader: ["varying vec3 vNormal;", "void main() {", "vNormal = normal;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
        fragmentShader: ["varying vec3 vNormal;", "void main() {", "vec3 color = normalize(vNormal);", "color = color * 0.5 + 0.5;", "gl_FragColor = vec4( color.x, color.y, color.z, 1.0 );", "}"].join("\n"),
        side: THREE.DoubleSide
    },
    e.exports = IJEWEL.DiamondShader = {
        defines: {
            RAY_BOUNCES: 5
        },
        vertexShader: ["varying vec2 vUv;", "varying vec3 Normal;", "varying vec3 worldNormal;", "varying vec3 vecPos;", "varying vec3 viewPos;", "void main() {", "vUv = uv;", "Normal =  normal;", "worldNormal = (modelMatrix * vec4(normal,0.0)).xyz;", "vecPos = (modelMatrix * vec4(position, 1.0 )).xyz;", "viewPos = (modelViewMatrix * vec4(position, 1.0 )).xyz;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
        fragmentShader: ["varying vec2 vUv;", "varying vec3 Normal;", "varying vec3 worldNormal;", "varying vec3 vecPos;", "varying vec3 viewPos;", "uniform samplerCube tCubeMapNormals;", "uniform samplerCube envMap;", "uniform samplerCube envRefractionMap;", "uniform sampler2D sphereMap;", "uniform float envMapIntensity;", "uniform float tanAngleSqCone;", "uniform float coneHeight;", "uniform int maxBounces;", "uniform mat4 modelMatrix;", "uniform mat4 invModelMatrix;", "uniform float n2;", "uniform float radius;", "uniform bool bDebugBounces;", "uniform float rIndexDelta;", "uniform float normalOffset;", "uniform float squashFactor;", "uniform float distanceOffset;", "uniform float geometryFactor;", "uniform vec3 Absorbption;", "uniform vec3 colorCorrection;", "uniform vec3 boostFactors;", "uniform vec3 centreOffset;", "vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {", "float dotNV = abs( dot( normal, viewDir ) );", "const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );", "const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );", "vec4 r = roughness * c0 + c1;", "float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;", "vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;", "return specularColor * AB.x + AB.y;", "}", "vec4 SampleSpecularReflection(vec4 specularColor, vec3 direction ) {", "direction.x *= -1.0;", "direction.z *= -1.0;", "vec3 tempDir = normalize(vec3(0., 0., 1.) + direction);", "vec4 sampleColorRGB = envMapIntensity * envMapTexelToLinear( textureCube( envMap, direction ) );", "vec4 sampleColorRefraction = envMapIntensity * ( texture2D( sphereMap, tempDir.xy * 0.5 + 0.5 ) );", "vec3 toneMappedColor = pow(toneMapping(sampleColorRGB.rgb),vec3(1./1.));", "return vec4(toneMappedColor, 1.0);", "}", "vec4 SampleSpecularContribution(vec4 specularColor, vec3 direction ) {", "direction = normalize(direction);", "direction.x *= -1.0;", "direction.z *= -1.0;", "vec4 sampleColorRGB = envMapIntensity * envMapTexelToLinear( textureCube( envMap, direction ) );", "vec3 tempDir = normalize(vec3(0., 0., 1.) + direction);", "float m = 2.8284271247461903 * sqrt( direction.z+1.0 );", "vec4 sampleColorRefraction = envMapIntensity * texture2D( sphereMap, clamp(direction.xy / m + 0.45, vec2(0.), vec2(1.)) );", "vec3 toneMappedColor = pow(toneMapping( sampleColorRGB.rgb ),vec3(1./1.));", "return vec4(toneMappedColor, 1.0);", "}", "vec3 intersectSphere(vec3 origin, vec3 direction) {", "origin -= centreOffset;", "direction.y /= squashFactor;", "float A = dot(direction, direction);", "float B = 2.0*dot(origin, direction);", "float C = dot(origin, origin) - radius * radius;", "float disc = B*B - 4.0 * A * C;", "if(disc > 0.0)", "{", "disc = sqrt(disc);", "float t1 = (-B + disc)*geometryFactor/A;", "float t2 = (-B - disc)*geometryFactor/A;", "float t = (t1 > t2) ? t1 : t2;", "direction.y *= squashFactor;", "return vec3(origin + centreOffset + direction * t);", "}", "return vec3(0.0);", "}", "vec3 debugBounces(int count) {", "vec3 color = vec3(1.,1.,1.);", "if(count == 1)", "color = vec3(0.0,1.0,0.0);", "else if(count == 2)", "color = vec3(0.0,0.0,1.0);", "else if(count == 3)", "color = vec3(1.0,1.0,0.0);", "else if(count == 4)", "color = vec3(0.0,1.0,1.0);", "else", "color = vec3(0.0,1.0,0.0);", "if(count ==0)", "color = vec3(1.0,0.0,0.0);", "return color;", "}", "vec3 traceRay(vec3 origin, vec3 direction, vec3 normal) {", "vec3 outColor = vec3(0.0);", "// Reflect/Refract ray entering the diamond", "const float n1 = 1.0;", "const float epsilon = 1e-4;", "float f0 = (2.4- n1)/(2.4 + n1);", "f0 *= f0;", "vec3 attenuationFactor = vec3(1.0);", "vec3 newDirection = refract(direction, normal, n1/n2);", "vec3 reflectedDirection = reflect(direction, normal);", "vec3 brdfReflected = BRDF_Specular_GGX_Environment(reflectedDirection, normal, vec3(f0), 0.0);", "vec3 brdfRefracted = BRDF_Specular_GGX_Environment(newDirection, -normal, vec3(f0), 0.0);", "attenuationFactor *= ( vec3(1.0) - brdfRefracted);", "outColor += SampleSpecularReflection(vec4(1.0), reflectedDirection ).rgb * brdfReflected;", "int count = 0;", "newDirection = (invModelMatrix * vec4(newDirection, 0.0)).xyz;", "newDirection = normalize(newDirection);", "origin = (invModelMatrix * vec4(origin, 1.0)).xyz;", "// ray bounces ", "for( int i=0; i<RAY_BOUNCES; i++) { ", "vec3 intersectedPos;", "intersectedPos = intersectSphere(origin + vec3(epsilon), newDirection);", "vec3 dist = intersectedPos - origin;", "vec3 d = normalize(intersectedPos - centreOffset);", "vec3 mappedNormal = textureCube( tCubeMapNormals, d ).xyz;", "mappedNormal = 2. * mappedNormal - 1.;", "mappedNormal.y += normalOffset;", "mappedNormal = normalize(mappedNormal);", "dist = (modelMatrix * vec4(dist, 1.)).xyz;", "float r = sqrt(dot(dist, dist));", "attenuationFactor *= exp(-r*Absorbption);", "// refract the ray at first intersection ", "vec3 oldOrigin = origin;", "origin = intersectedPos - normalize(intersectedPos - centreOffset) * distanceOffset;", "vec3 oldDir = newDirection;", "newDirection = refract(newDirection, mappedNormal, n2/n1);", "if( dot(newDirection, newDirection) == 0.0) { // Total Internal Reflection. Continue inside the diamond ", "newDirection = reflect(oldDir, mappedNormal);", "if(i == RAY_BOUNCES-1 ) //If the ray got trapped even after max iterations, simply sample along the outgoing refraction! ", "{", "vec3 brdfReflected = BRDF_Specular_GGX_Environment(-oldDir, mappedNormal, vec3(f0), 0.0);", "vec3 d1 = (modelMatrix * vec4(oldDir, 0.0)).xyz;", "outColor += SampleSpecularContribution(vec4(1.0), d1 ).rgb * colorCorrection * attenuationFactor  * boostFactors * (vec3(1.0) - brdfReflected);", "//outColor = vec3(1.,0.,0.);", "//if(d1.y > 0.95) {", "//outColor += d1.y * vec3(1.,0.,0) * attenuationFactor * (vec3(1.0) - brdfReflected) * boostFactors;", "//}", "}", "} else { // Add the contribution from outgoing ray, and continue the reflected ray inside the diamond ", "vec3 brdfRefracted = BRDF_Specular_GGX_Environment(newDirection, -mappedNormal, vec3(f0), 0.0);", "// outgoing(refracted) ray's contribution ", "vec3 d1 = (modelMatrix * vec4(newDirection, 0.0)).xyz;", "vec3 colorG = SampleSpecularContribution(vec4(1.0), d1 ).rgb * ( vec3(1.0) - brdfRefracted);", "vec3 dir1 = refract(oldDir, mappedNormal, (n2+rIndexDelta)/n1);", "vec3 dir2 = refract(oldDir, mappedNormal, (n2-rIndexDelta)/n1);", "vec3 d2 = (modelMatrix * vec4(dir1, 0.0)).xyz;", "vec3 d3 = (modelMatrix * vec4(dir2, 0.0)).xyz;", "vec3 colorR = SampleSpecularContribution(vec4(1.0), d2 ).rgb * ( vec3(1.0) - brdfRefracted);", "vec3 colorB = SampleSpecularContribution(vec4(1.0), d3 ).rgb * ( vec3(1.0) - brdfRefracted);", "outColor += vec3(colorR.r, colorG.g, colorB.b) * colorCorrection * attenuationFactor * boostFactors;", "//outColor = oldDir;", "//new reflected ray inside the diamond ", "newDirection = reflect(oldDir, mappedNormal);", "vec3 brdfReflected = BRDF_Specular_GGX_Environment(newDirection, mappedNormal, vec3(f0), 0.0);", "attenuationFactor *= brdfReflected * boostFactors;", "count++;", "}", "}", "if(false)", "outColor = debugBounces(count);", "return outColor;", "}", "void main() {", "vec3 normalizedNormal = normalize(worldNormal);", "vec3 viewVector = normalize(vecPos - cameraPosition);", "vec3 color = traceRay(vecPos, viewVector, normalizedNormal);", "gl_FragColor = vec4(color.rgb,1.);", "#include <tonemapping_fragment>", "//#include <encodings_fragment>", "//gl_FragColor = textureCube(tCubeMapNormals, normalize(Normal));", "}"].join("\n"),
        uniforms: {
            tCubeMapNormals: {
                type: "t",
                value: null
            },
            envMap: {
                type: "t",
                value: null
            },
            envRefractionMap: {
                type: "t",
                value: null
            },
            sphereMap: {
                type: "t",
                value: null
            },
            envMapIntensity: {
                type: "f",
                value: 1
            },
            maxBounces: {
                type: "i",
                value: 1
            },
            tanAngleSqCone: {
                type: "f",
                value: 0
            },
            coneHeight: {
                type: "f",
                value: 0
            },
            bDebugBounces: {
                type: "i",
                value: !1
            },
            rIndexDelta: {
                type: "f",
                value: .012
            },
            n2: {
                type: "f",
                value: 2.4
            },
            radius: {
                type: "f",
                value: 1
            },
            normalOffset: {
                type: "f",
                value: 0
            },
            squashFactor: {
                type: "f",
                value: .98
            },
            distanceOffset: {
                type: "f",
                value: 0
            },
            geometryFactor: {
                type: "f",
                value: .28
            },
            Absorbption: {
                type: "v3",
                value: new THREE.Vector3(0,0,0)
            },
            colorCorrection: {
                type: "v3",
                value: new THREE.Vector3(1,1,1)
            },
            boostFactors: {
                type: "v3",
                value: new THREE.Vector3(.892,.892,.98595025)
            },
            centreOffset: {
                type: "v3",
                value: new THREE.Vector3(0,0,0)
            }
        },
        side: THREE.DoubleSide
    },
    e.exports = IJEWEL.SparkleShader = {
        vertexShader: ["varying vec2 vUv;", "varying vec4 sparkleProjectedCentre;", "uniform mat4 ModelViewMatrix;", "uniform float scale;", "uniform float rotation;", "void main() { ", "vUv = uv; ", "vec4 finalPosition;", "vec2 alignedPosition = position.xy * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "finalPosition = ModelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "sparkleProjectedCentre = projectionMatrix * ModelViewMatrix * vec4(0.0,0.0,0.0,1.0 );", "gl_Position = finalPosition;", "}"].join("\n"),
        fragmentShader: ["varying vec2 vUv;", "varying vec4 sparkleProjectedCentre;", "uniform sampler2D sparkleTexture;", "uniform sampler2D screenTexture;", "uniform sampler2D noiseTexture;", "uniform float intensity;", "vec3 ClosestPrimaryColor(vec3 color) {", "vec3 diffColor1 = vec3(1.0,0.0,0.0) - color;", "vec3 diffColor2 = vec3(0.0,1.0,0.0) - color;", "vec3 diffColor3 = vec3(0.0,0.0,1.0) - color;", "const float margin = 0.5; ", "if(dot(diffColor1, diffColor1) < margin)", "return vec3(1.0, margin, margin); ", "if(dot(diffColor2, diffColor2) < margin)", "return vec3(margin, 1.0, margin);", "if(dot(diffColor3, diffColor3) < margin)", "return vec3(margin, margin, 1.0);", "return color;", "}", "void main() {", "vec2 uv = (sparkleProjectedCentre.xy/sparkleProjectedCentre.w + 1.0)*0.5;", "vec4 screenColor = texture2D( screenTexture, uv );", "//screenColor.rgb = ClosestPrimaryColor(screenColor.rgb);", "float noise = texture2D( noiseTexture, uv ).r;", "screenColor.xyz *= screenColor.xyz;", "screenColor.xyz *= screenColor.xyz;", "screenColor.xyz *= screenColor.xyz;", "//float luminance = dot(vec3(0.3, 0.59, 0.11), screenColor.xyz);", "//luminance = luminance > 0.0 ? luminance : 0.0;", "vec4 spriteColor = vec4(1.) * texture2D( sparkleTexture, vUv ).a * screenColor * noise * intensity;", "gl_FragColor = spriteColor;", "}"].join("\n"),
        uniforms: {
            ModelViewMatrix: {
                type: "m4",
                value: (new THREE.Matrix4).identity()
            },
            sparkleTexture: {
                type: "t",
                value: null
            },
            screenTexture: {
                type: "t",
                value: null
            },
            noiseTexture: {
                type: "t",
                value: null
            },
            scale: {
                type: "f",
                value: 1
            },
            rotation: {
                type: "f",
                value: 0
            },
            intensity: {
                type: "f",
                value: 1
            }
        },
        side: THREE.DoubleSide
    },
    e.exports = IJEWEL.normalMapCaptureMaterial = new THREE.ShaderMaterial(IJEWEL.NormalMapCaptureShader),
    e.exports = IJEWEL.diamondMaterial = new THREE.ShaderMaterial(IJEWEL.DiamondShader)
}
, function(e, t) {
    e.exports = IJEWEL.Sparkle = class e {
        constructor(e, t) {
            this.texture = e,
            this.noiseTexture = t,
            this.geometry = new THREE.PlaneGeometry(1,1,0),
            this.material = new THREE.ShaderMaterial,
            this.material.depthTest = !1,
            this.material.depthWrite = !1,
            this.material.transparent = !0,
            this.material.side = THREE.DoubleSide,
            this.material.blending = THREE.AdditiveBlending,
            this.material.vertexShader = IJEWEL.SparkleShader.vertexShader,
            this.material.fragmentShader = IJEWEL.SparkleShader.fragmentShader,
            this.material.uniforms = THREE.UniformsUtils.clone(IJEWEL.SparkleShader.uniforms),
            void 0 !== this.texture && (this.material.uniforms.sparkleTexture.value = e),
            void 0 !== this.noiseTexture && (this.material.uniforms.noiseTexture.value = t),
            this.mesh = new THREE.Mesh(this.geometry,this.material),
            this.mesh.positionOffset = new THREE.Vector3,
            this.rotationSpeedFactor = 5
        }
        shallowCopy() {
            var t = new e(this.texture,this.noiseTexture);
            return t.mesh.positionOffset = new THREE.Vector3,
            t.mesh.positionOffset.copy(this.mesh.positionOffset),
            t.material.uniforms.scale.value = this.material.uniforms.scale.value,
            t.material.uniforms.rotation.value = this.material.uniforms.rotation.value,
            t.material.uniforms.intensity.value = this.material.uniforms.intensity.value,
            t.material.uniforms.screenTexture.value = this.material.uniforms.screenTexture.value,
            t.material.uniforms.noiseTexture.value = this.material.uniforms.noiseTexture.value,
            t.material.uniforms.ModelViewMatrix.value.copy(this.material.uniforms.ModelViewMatrix.value),
            t.rotationSpeedFactor = this.rotationSpeedFactor,
            t
        }
        setScale(e) {
            this.material.uniforms.scale.value = e
        }
        setIntensity(e) {
            this.material.uniforms.intensity.value = e
        }
        setRotation(e) {
            this.material.uniforms.rotation.value = e
        }
        setRotationSpeedFactor(e) {
            this.rotationSpeedFactor = e
        }
        setPositionOffset(e, t, o) {
            this.mesh.positionOffset.x = e,
            this.mesh.positionOffset.y = t,
            this.mesh.positionOffset.z = o,
            this.mesh.position.copy(this.mesh.positionOffset),
            this.mesh.updateMatrix()
        }
        alignWithCamera(e) {
            this.mesh.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, this.mesh.matrix),
            this.material.uniforms.ModelViewMatrix.value.copy(this.mesh.modelViewMatrix)
        }
        syncWithTransform(e, t) {
            this.mesh.position.copy(this.mesh.positionOffset),
            t && this.mesh.position.add(t),
            this.mesh.position.applyMatrix4(e),
            this.mesh.updateMatrix()
        }
    }
}
]);
